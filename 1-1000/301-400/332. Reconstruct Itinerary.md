# 332. Reconstruct Itinerary
###### tags: `LeetCode`
## **Link**
https://leetcode.com/problems/reconstruct-itinerary
## **純DFS**
```cpp=
class Solution {
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) 
    {
        n=tickets.size();
        // 建圖
        for(auto &v:tickets)
        {
            ump[v[0]].push_back(v[1]);
            index[v[0]].push_back(false);
            st.insert(v[0]);
            st.insert(v[1]);
        }
        // sort 因為題目要求最小字典序
        for(auto &v:st)
            sort(ump[v].begin(),ump[v].end());
        // 從題目要求的起點"JFK"開始
        dfs("JFK");
        return ans;
    }
private:
    int n;
    unordered_map<string,vector<string>> ump;
    unordered_map<string,vector<bool>> index;
    set<string> st;
    vector<string> vt,ans;
    void dfs(const string &s)
    {
        // 把這個點存起來
        vt.push_back(s);
        // 目前的路徑已經走完所有邊 = 終止條件
        if(vt.size()==n+1)
        {
            ans=vt;
            vt.pop_back();
            return;
        }
        // 窮舉以這個點為起點的所有邊 
        // 如果已經找到解答 -> 不可能找到字典序更小的答案
        for(int i=0;ans.empty() && i<ump[s].size();++i)
        {
            // 如果這條邊目前是可以走的
            if(!index[s][i])
            {
                // 把邊改成不能走
                index[s][i]=true;
                // 以該邊終點為dfs的新起點
                dfs(ump[s][i]);
                // 把邊改成可以走
                index[s][i]=false;
            }
        }
        // 把這個點丟掉
        vt.pop_back();
    }
};
```
## **別人利用題目特性的DFS**
```cpp=
class Solution {
public:
    unordered_map<string,priority_queue<string,vector<string>,greater<string>>> map; 
    vector<string> ans;
    void dfs(string s)
    {
        auto &x=map[s];
        while(!x.empty())
        {
            string to=x.top();
            x.pop();
            dfs(to);
        }
        cout<<s<<endl;
        ans.push_back(s);
    }
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        for(auto &x:tickets)
            map[x[0]].push(x[1]);
        dfs("JFK");
        reverse(ans.begin(),ans.end());
        return ans;
    }
};
```
## **題目特性**
這題的特性是<font color="#00ff00">**歐拉迴路(Eulerian Circuit)**</font>，最多只會有一個出度小於入度的點。

於是我們可以得到結論：
1. 若存在此點，則此點必為終點 -> 把目前路徑的點存到陣列中，然後把剩下的點dfs找完之後再放到陣列裡 -> 整個陣列反轉即為答案
3. 若不存在此點 -> 那就是直接dfs -> 整個陣列反轉即為答案

由於我們是用dfs存答案，所有路徑都會是反向的，因此必須將陣列反轉。
## date
**2023.09.14**
