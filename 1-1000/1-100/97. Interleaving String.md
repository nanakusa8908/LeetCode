# 97. Interleaving String
###### tags: `LeetCode`
## **Link**
https://leetcode.com/problems/interleaving-string/description/
## **Code**
```cpp=
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) 
    {
        dp.resize(s1.size()+1,vector<int>(s2.size()+1,-1));
        return solve(s1,s2,s3,0,0);
    }
private:
    vector<vector<int>> dp;
    bool solve(string &s1, string &s2, string &s3, int i1,int i2)
    {
        bool rt;
        // 已經組成s3了->要把s1和s2都用完
        // 換句話說 s1.size()+s2.size()!=s3.size() 的話必無解
        if(i1+i2==s3.size())
            return dp[i1][i2]=(i1==s1.size()) && (i2==s2.size());
        // 如果(i1,i2)以前已經找過了
        if(dp[i1][i2]!=-1)
            return dp[i1][i2];
        // 情況一： i1和i2都可以是接下來的字母
        if(i1<s1.size() && i2<s2.size() && s1[i1]==s3[i1+i2] && s2[i2]==s3[i1+i2])
            rt = solve(s1,s2,s3,i1+1,i2) | solve(s1,s2,s3,i1,i2+1);
        // 情況二： 只有i1可以是接下來的字母
        else if(i1<s1.size() && s1[i1]==s3[i1+i2])
            rt = solve(s1,s2,s3,i1+1,i2);
        // 情況三： 只有i2可以是接下來的字母
        else if(i2<s2.size() && s2[i2]==s3[i1+i2])
            rt = solve(s1,s2,s3,i1,i2+1);
        return dp[i1][i2]=rt;
    }
};
```
## date
**2023.08.25**
