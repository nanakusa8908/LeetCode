# 472. Concatenated Words
###### tags: `LeetCode`
## **Link**
https://leetcode.com/problems/concatenated-words/
## **Code**
```cpp=
class Solution {
public:
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) 
    {
        unordered_set<string> st; // 單字表
        vector<string> ans; // 準備回傳的答案
        vector<int> ct; // 用來存從頭到目前這個字母可以切成幾段 // 不一定是最大的段數，因為題目只有要求至少切成兩段
        string str; // 暫存substring的東西
        int n; // 目前處理的字串長度
        for(string &v:words) // 全部單字塞進去單字表裡面
            st.insert(v);
        for(string &v:words) // 每個單字都做一次
        {
            n=v.size(); // 算單字長度
            ct.clear(); // 清掉ct
            ct.resize(n); // 調整ct的大小
            for(int j=0;j<n;++j) // ct歸零
                ct[j]=0;
            for(int j=0;j<n;++j) // 從第一個字母開始看
            {
                for(int k=j-1;k>=0;--k) // 從目前字母的前一個開始，倒著做回來
                {
                    if(ct[k]==0) // 如果這個字母不是一個可行的切點，繼續往前找
                        continue;
                    str=v.substr(k+1,j-k); // 以k為切點，找出k+1到j的子字串
                    if(st.find(str)!=st.end()) // 如果str有出現在單字表
                    {
                        ct[j]=ct[k]+1; // 現在這個字前面可以切的段數至少是ct[k]+1
                        break;
                    }
                }
                if(ct[j]==0) // 如果可行切點都不符合條件，那0到j也是一個切法
                {
                    str=v.substr(0,j+1); // 0到j的子字串
                    if(st.find(str)!=st.end()) // 如果str有出現在單字表
                        ct[j]=1;// 現在這個字前面可以切的段數就是1
                }
            }
            if(ct[n-1]>=2) //如果最後一個字母之前的可行切點大於1
                ans.push_back(v); // 此字串就是我們要找的字串
        }
        return ans;
    }
};
```
## date
**2023.01.28**
