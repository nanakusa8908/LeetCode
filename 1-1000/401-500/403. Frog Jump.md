# 403. Frog Jump
###### tags: `LeetCode`
## **Link**
https://leetcode.com/problems/frog-jump/
## **Code**
```cpp=
class Solution {
public:
    bool canCross(vector<int>& stones) 
    {
        // 為了之後可以平均O(1)查詢建表
        for(int i=0;i<stones.size();++i)
            ump[stones[i]]=i;
        vector<vector<int>> dp(stones.size(),vector<int>(stones.size(),-1));
        return sol(dp,stones,0,0);
    }
private:
    unordered_map<int,int> ump;
    // idx對應的是stones的索引 // k代表從上顆石頭跳到這顆石頭的距離
    bool sol(vector<vector<int>> &dp, vector<int> &stones, int idx, int k)
    {
        // 已經跳到最後一顆石頭的話
        if(idx==stones.size()-1)
            return dp[idx][k]=true;
        // 這組(idx,k)之前已經走過的話
        if(dp[idx][k]!=-1)
            return dp[idx][k];
        bool rt=false;
        // 下一步跳k-1的情況
        if(k-1>0 && ump[stones[idx]+k-1]!=0)
            rt|=sol(dp,stones,ump[stones[idx]+k-1],k-1);
        // 下一步跳k的情況
        if(ump[stones[idx]+k]!=0)
            rt|=sol(dp,stones,ump[stones[idx]+k],k);
        // 下一步跳k+1的情況
        if(ump[stones[idx]+k+1]!=0)
            rt|=sol(dp,stones,ump[stones[idx]+k+1],k+1);
        return dp[idx][k]=rt;
    }
};
```
## 難得的備註
unordered_map如果查詢未在unordered_map裡面的索引，會幫他開一個空間，且該對應的second為0。
## date
**2023.08.27**
