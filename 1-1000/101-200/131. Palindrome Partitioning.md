# 131. Palindrome Partitioning
###### tags: `LeetCode`
## **Link**
https://leetcode.com/problems/palindrome-partitioning/
## **遞迴版（100ms）**
```cpp=
class Solution {
public:
    bool isPa(string s)
    {
        int sz=s.size();
        for(int i=0;i<sz/2;++i)
            if(s[i]!=s[sz-i-1])
                return false;
        return true;
    }
    void dfs(int n, vector<string> &kp, vector<vector<string>> &ans, string s)
    {
        int sz=s.size();
        string st;
        for(int i=1;i<=sz-n;++i)
        {
            st=s.substr(n,i);
            if(isPa(st))
            {
                kp.push_back(st);
                if(n+i==sz)
                    ans.push_back(kp);
                else
                    dfs(n+i,kp,ans,s);
                kp.pop_back();
            }
        }
    }
    vector<vector<string>> partition(string s) 
    {
        vector<vector<string>> ans;
        vector<string> kp;
        dfs(0,kp,ans,s);
        return ans;
    }
};
```
## **迴圈版（204ms）**
```cpp=
class Solution {
public:
    vector<vector<string>> partition(string s) 
    {
        int n=s.size(),sz;
        vector<vector<string>> ans;
        vector<vector<vector<string>>> kp(s.size());
        bool fg;
        vector<string> tmp;
        string st;
        for(int i=0;i<n;++i)
        {
            for(int j=0;j<=i;++j)
            {
                fg=true;
                st=s.substr(j,i-j+1);
                sz=st.size();
                for(int k=0;k<sz/2;++k)
                {
                    if(st[k]!=st[sz-k-1])
                    {
                        fg=false;
                        break;
                    }
                }
                if(fg)
                {
                    if(j==0)
                    {
                        tmp.clear();
                        tmp.push_back(st);
                        kp[i].push_back(tmp);
                    }
                    else
                    {
                        for(int k=0;k<kp[j-1].size();++k)
                        {
                            kp[i].push_back(kp[j-1][k]);
                            kp[i].back().push_back(st);
                        }
                    }
                }
            }
        }
        for(int j=0;j<kp[n-1].size();++j)
            ans.push_back(kp[n-1][j]);
        return ans;
    }
};
```
## date
**2023.01.22**
