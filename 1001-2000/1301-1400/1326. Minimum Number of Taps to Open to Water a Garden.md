# 1326. Minimum Number of Taps to Open to Water a Garden
###### tags: `LeetCode`
## **Link**
https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/
## **Code: Greedy**
```cpp=
class Solution {
public:
    int minTaps(int n, vector<int>& ranges) 
    {
        int idx=0,r=0,rr=0,ans=0;
        vector<pair<int,int>> rg;
        for(int i=0;i<ranges.size();++i)
            rg.push_back({max(0,i-ranges[i]),min(n,i+ranges[i])});
        sort(rg.begin(),rg.end());
        // 如果還沒覆蓋到最右邊
        while(rr<n)
        {
            for(;idx<n+1;++idx)
            {
                // 嘗試所有左邊在目前範圍內的水龍頭
                if(rg[idx].first>rr)
                    break;
                // 找到可以覆蓋到的最右邊
                r=max(r,rg[idx].second);
            }
            // r=rr表示沒有沒辦法繼續往右 -> 無解
            if(r==rr)
                return -1;
            // 更新範圍
            rr=r;
            ++ans;
        }
        return ans;
    }
};
```
## **Code: DP**
```cpp=
class Solution {
public:
    int minTaps(int n, vector<int>& ranges) 
    {
        int l,r,rr=0;
        vector<pair<int,int>> rg;
        for(int i=0;i<ranges.size();++i)
            rg.push_back({i-ranges[i],i+ranges[i]});
        sort(rg.begin(),rg.end());
        vector<int> dp(n+1,99999999);
        dp[0]=0;
        for(int i=0;i<rg.size();++i)
        {
            // l是左邊界 r是右邊界 
            l=max(0,rg[i].first);
            r=min(n,rg[i].second);
            if(dp[l]!=99999999)
            {
                // 嘗試更新最小值
                dp[r]=min(dp[r],dp[l]+1);
                // 嘗試更新未更新區段的最小值
                for(int j=r-1;j>=rr;--j)
                    dp[j]=min(dp[j+1],dp[j]);
            }
            rr=max(r,rr);
        }
        // 無解的情況
        if(dp[n]==99999999)
            return -1;
        return dp[n];
    }
};
```
## 備註
在每個點都只有兩項的時候，如果有sort和查詢的話，
vector<vector<int>>的速度會比vector<pair<int,int>>慢很多（不確定是誰在慢），
vector<vector<int>>的空間會比vector<pair<int,int>>大不少。
## date
**2023.08.31**
