# 2876. Count Visited Nodes in a Directed Graph
###### tags: `LeetCode`
## **Link**
https://leetcode.com/problems/count-visited-nodes-in-a-directed-graph
## **Code**
```cpp=
class Solution {
public:
    vector<int> countVisitedNodes(vector<int>& edges) 
    {
        vector<int> ans(edges.size(),1);
        for(int i=0;i<edges.size();++i)
        {
            // 如果i還沒有被做過dfs
            if(edges[i]!=-1)
            {
                sz=0; // sz用來存這個點可以到幾個點
                chk=0; // 如果現在在環裡面 chk=0, 否則 chk=1
                rr=-1; // 如果存在環 rr會是對於這次dfs環的頭 
                       // rr=-1代表這次dfs不存在環
                ust.clear(); // ust用來快速查詢這次dfs經過的點
                visited.clear(); // visited存這次dfs的路徑
                dfs(edges,ans,i);
            }
        }
        return ans;
    }
private:
    int sz,chk,rr;
    unordered_set<int> ust;
    vector<int> visited;
    void dfs(vector<int> &edges, vector<int> &ans, int idx)
    {
        visited.push_back(idx); // 把目前點存進路徑
        ust.insert(idx); // 把目前點存進查詢表
        
        // 終止條件1: 下一個點已經被dfs過了
        if(edges[edges[idx]]==-1)
        {
            sz=ans[edges[idx]]; // 初始sz
            chk=1; // 初始chk
            ans[idx]+=sz; // 算答案
            edges[idx]=-1; // 斷邊
            return;
        }
        // 終止條件2: 遇到環了
        else if(ust.count(edges[idx]))
        {
            rr=edges[idx]; // 把環的頭存起來
            for(int i=visited.size()-1;i>=0;--i) // 路徑回推sz
                if(visited[i]==edges[idx])
                    break;
                else
                    ++sz;
            chk=0; // 初始chk
            ans[idx]+=sz; // 算答案
            edges[idx]=-1; // 斷邊
            return;
        }
        // 非終止條件
        else
        {
            dfs(edges,ans,edges[idx]); // dfs
            sz+=chk; // 更新sz
            ans[idx]+=sz; // 算答案
            if(rr==idx) // 如果要離開環了
                ++chk;
            edges[idx]=-1; // 斷邊
            return;
        }
    }
};
```
## date
**2023.10.01**
