# 2246. Longest Path With Different Adjacent Characters
###### tags: `LeetCode`

## **Link**
https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/

## **Code**
```cpp=
class Solution {
public:
    int longestPath(vector<int>& parent, string s) 
    {
        int n=parent.size();
        vector<vector<int>> child(n); //子節點陣列
        vector<int> longestDepth(n,1),childNum(n); //longestDepth存這個點到可以不相鄰重複的最深深度，childNum存還沒處理的子節點數量
        queue<int> que; //準備要處理的點
        priority_queue<int> pq; //用來算最深深度和目前節點最佳解
        for(int i=n-1;i>0;--i)
            child[parent[i]].push_back(i);
        for(int i=0;i<n;++i)
            childNum[i]=child[i].size();
        for(int i=0;i<n;++i)
            if(!childNum[i])
                que.push(i);
        int now,ans=-1,nowMax;
        while(!que.empty())
        {
            now=que.front();
            que.pop();
            while(!pq.empty())
                pq.pop();
            for(int i=0;i<child[now].size();++i)
                if(s[now]!=s[child[now][i]])
                    pq.push(longestDepth[child[now][i]]);
            if(!pq.empty())
                longestDepth[now]=pq.top()+1;
            nowMax=0;
            for(int i=0;i<2 && !pq.empty();++i)
            {
                nowMax+=pq.top();
                pq.pop();
            }
            ans=max(ans,nowMax+1);
            if(now!=0)
                --childNum[parent[now]];
            if(now!=0 && !childNum[parent[now]])
                que.push(parent[now]);
        }
        return ans;
    }
};
```
## date
**2023.01.13**
