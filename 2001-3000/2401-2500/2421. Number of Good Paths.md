# 2421. Number of Good Paths
###### tags: `LeetCode`
## **Link**
https://leetcode.com/problems/number-of-good-paths/

## **Code**
```cpp=
class Solution {
public:
    int findTop(int n, vector<int> &djs)
    {
        if(djs[n]!=n)
            return djs[n]=findTop(djs[n],djs);
        return n;
    }
    int numberOfGoodPaths(vector<int> &vals, vector<vector<int>> &edges) 
    {
        map<int,vector<int>> mp;
        unordered_map<int,int> ct,fin;
        vector<vector<int>> tree(vals.size());
        vector<int> djs(vals.size());
        int ans=0;
        for(int i=0;i<vals.size();++i)
            mp[vals[i]].push_back(i);
        for(int i=0;i<vals.size();++i)
            djs[i]=i;
        for(int i=0;i<edges.size();++i)
        {
            tree[edges[i][0]].push_back(edges[i][1]);
            tree[edges[i][1]].push_back(edges[i][0]);
        }
        for(auto v:mp)
        {
            ct.clear();
            fin.clear();
            for(int i=0;i<v.second.size();++i)
            {
                for(int j=0;j<tree[v.second[i]].size();++j)
                {
                    if(vals[tree[v.second[i]][j]]<=vals[v.second[i]])
                    {
                        djs[findTop(tree[v.second[i]][j],djs)]=djs[findTop(v.second[i],djs)];
                    }
                }
                ct[findTop(v.second[i],djs)]++;
            }
            for(auto vv:ct)
                fin[findTop(vv.first,djs)]+=vv.second;
            for(auto vv:fin)
                ans+=(vv.second*(vv.second+1)/2);
        }
        return ans;
    }
};
```
## date
**2023.01.16**
